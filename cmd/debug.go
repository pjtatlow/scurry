package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/pjtatlow/scurry/internal/db"
	"github.com/pjtatlow/scurry/internal/ui"
)

var debugCmd = &cobra.Command{
	Use:   "debug <error-report-file>",
	Short: "Debug a push error by replaying migrations",
	Long: `Debug a push error by replaying the migrations from an error report file.

This command parses the YAML error report generated by a failed push, sets up a test
database with the remote schema, and replays the migrations one by one to identify
exactly which statement fails.

Example:
  scurry debug /tmp/scurry-push-error-abc123.yaml`,
	Args: cobra.ExactArgs(1),
	RunE: debug,
}

func init() {
	rootCmd.AddCommand(debugCmd)
}

// ErrorReport contains the parsed contents of an error report file
type ErrorReport struct {
	Generated        string   `yaml:"generated"`
	Error            string   `yaml:"error"`
	LocalStatements  []string `yaml:"local_schema"`
	RemoteStatements []string `yaml:"remote_schema"`
	Migrations       []string `yaml:"migrations"`
}

func debug(cmd *cobra.Command, args []string) error {
	reportPath := args[0]

	report, err := parseErrorReport(reportPath)
	if err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}

	err = doDebug(cmd.Context(), report)
	if err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}

	return nil
}

func doDebug(ctx context.Context, report *ErrorReport) error {
	fmt.Println(ui.Header("Debugging Push Error"))
	fmt.Println()

	// Show the original error
	fmt.Println(ui.Info("Original error:"))
	fmt.Println(ui.Error(report.Error))
	fmt.Println()

	// Check if we have migrations to replay
	if len(report.Migrations) == 0 {
		fmt.Println(ui.Warning("No migrations found in error report. The error occurred before migration generation."))
		return nil
	}

	fmt.Println(ui.Info(fmt.Sprintf("Found %d remote schema statement(s) and %d migration(s) to replay", len(report.RemoteStatements), len(report.Migrations))))
	fmt.Println()

	// Create shadow database
	fmt.Println(ui.Subtle("→ Creating test database..."))
	client, err := db.GetShadowDB(ctx)
	if err != nil {
		return fmt.Errorf("failed to create test database: %w", err)
	}
	defer client.Close()

	// Apply remote schema to set up initial state
	if len(report.RemoteStatements) > 0 {
		fmt.Println(ui.Subtle("→ Applying remote schema to establish initial state..."))
		if err := client.ExecuteBulkDDL(ctx, report.RemoteStatements...); err != nil {
			return fmt.Errorf("failed to apply remote schema: %w", err)
		}
		fmt.Println(ui.Success("  ✓ Remote schema applied successfully"))
	}
	fmt.Println()

	// Replay migrations one by one
	fmt.Println(ui.Header("Replaying migrations:"))
	fmt.Println()

	for i, stmt := range report.Migrations {
		fmt.Printf("%s %s\n", ui.Info(fmt.Sprintf("%d.", i+1)), ui.SqlCode(stmt))

		if err := client.ExecuteBulkDDL(ctx, stmt); err != nil {
			fmt.Println()
			fmt.Println(ui.Error(fmt.Sprintf("✗ Statement %d failed:", i+1)))
			fmt.Println()
			fmt.Println(ui.SqlCode(stmt))
			fmt.Println()
			fmt.Println(ui.Error(fmt.Sprintf("Error: %s", err)))
			return nil // We found the failing statement, exit gracefully
		}

		fmt.Println(ui.Success("  ✓ Success"))
		fmt.Println()
	}

	fmt.Println(ui.Success("✓ All migrations replayed successfully!"))
	fmt.Println()
	fmt.Println(ui.Warning("The migrations succeeded in the test database. The original error may have been caused by:"))
	fmt.Println("  • Concurrent schema changes")
	fmt.Println("  • Data-dependent constraints")
	fmt.Println("  • Permission issues")
	fmt.Println("  • Network/connection issues")

	return nil
}

// parseErrorReport reads and parses a YAML error report file
func parseErrorReport(path string) (*ErrorReport, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open error report: %w", err)
	}

	report := &ErrorReport{}
	if err := yaml.Unmarshal(data, report); err != nil {
		return nil, fmt.Errorf("failed to parse error report: %w", err)
	}

	return report, nil
}
